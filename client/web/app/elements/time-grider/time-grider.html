<dom-module id="time-grider">
    <style is="custom-style">
        #grids{
            width: 100%;
            height: 55px;

            @apply(--layout-horizontal);
        }
        .section-parent{
            @apply(--layout-horizontal);
        }
        .draggable{
            width: 5px;
            height: 55px;
        }
        .dragging {
            cursor: col-resize;
        }
        .dragging paper-button {
            cursor:inherit;
        }

        paper-button.blue {
            background: var(--paper-light-blue-500);
            --paper-button-flat-focus-color: var(--paper-light-blue-50);
        }
        paper-button.selected {
            background: var(--paper-light-blue-200);
        }
        paper-button{
            height: 55px;
            width: 100%;
            min-width: 1px !important;
            margin: 0 0 0 0px !important;
            padding: 0px;
        }

    </style>
    <template>
        <p style="z-index:10; position:fixed;" id="timeTooltip"></p>
        <div id="grids"></div>
    </template>
    <script>
        Polymer({
            is: "time-grider",
            googleYoutube: document.getElementById("googleYoutube"),
            properties: {
                editable: {
                    type: Boolean,
                    value: false
                },
                mappings: {
                    type: Object,
                    notify: true
                },
                duration: {
                    type: Number,
                    notify: true
                }
            },
            observers: [
                'mappingChanged(mappings, duration)'
            ],
            ready: function() {},
            markAsSelected: function(mappingIndex) {
                while (this.$$(".selected") !== null) {
                    this.$$(".selected").classList.remove('selected');
                }
                this.$$("#" + "section-" + mappingIndex).classList.add('selected');
            },
            fireSelectionChanged: function(mappingIndex) {
                this.fire('choose-slide', {
                    index: mappingIndex,
                    element: this.mappings[mappingIndex]
                });
            },
            mappingChanged: function() {
                if (this.mappings.length === 0) {
                    return;
                }
                console.log("Mappings have changed: " + JSON.stringify(this.mappings));

                var self = this;
                var secToSlides = this.mappings;

                function getContainerId(num) {
                    return "container-" + num;
                }

                function getSectionId(num) {
                    return "section-" + num;
                }

                function getDraggableId(num) {
                    return "draggable-" + num;
                }

                function calculateWidth(elemDur) {
                    return (elemDur / self.duration) * 100 + "%";
                }

                function createGridCell(i, elemDur, draggable) {
                    var container = document.createElement("div");
                    container.id = getContainerId(i);
                    container.className = "section-parent grid-elem";
                    container.appendChild(createSection(i));
                    container.style.width = calculateWidth(elemDur);
                    if (draggable !== undefined) {
                        container.appendChild(draggable);
                    }
                    Polymer.dom(self.$.grids).appendChild(container);
                }

                function createSection(i) {
                    var grid = document.createElement("paper-button");
                    grid.raised = true;
                    grid.id = getSectionId(i);
                    grid.className = "section blue";
                    grid.textContent = " ";
                    grid.addEventListener("tap", click(i));
                    return grid;
                }

                function createDraggable(i) {
                    var div = document.createElement("div");
                    div.id = getDraggableId(i);
                    if (self.editable === true) {
                        div.className = "draggable dragging";
                        div.addEventListener("track", drag(i));
                    } else {
                        div.className = "draggable";
                    }
                    return div;
                }

                function getTimeForIndex(index) {
                    if (index >= self.mappings.length) {
                        return self.duration;
                    } else if (index < 0) {
                        return 0;
                    } else {
                        return self.mappings[index].time;
                    }
                }

                function updateTime(track, index) {
                    if (index < self.mappings.length) {
                        self.mappings[index].time = Math.round(calculateNewTime(track, index));
                    }
                }

                function calculateNewTime(track, index) {
                    var minTime = 8;
                    var newTime = getTimeForIndex(index) + (self.duration / self.$.grids.offsetWidth) * track.dx;

                    //Left
                    var leftConstraint = getTimeForIndex(index - 1) + minTime;
                    if (newTime < leftConstraint) {
                        return leftConstraint;
                    }

                    //Right
                    var rightConstraint = getTimeForIndex(index + 1) - minTime;
                    if (newTime > rightConstraint) {
                        return rightConstraint;
                    }

                    return newTime;
                }

                function resizeElements(track, index) {
                    function resizeElement(elemDur, index) {
                        self.$$("#" + getContainerId(index)).style.width = calculateWidth(elemDur);
                    }

                    var rightTime = calculateNewTime(track, index + 1);
                    resizeElement(rightTime - self.mappings[index].time, index);
                    resizeElement(getTimeForIndex(index + 2) - rightTime, index + 1);

                    displayTooltip(rightTime, track);
                }

                function displayTooltip(value, track) {
                    self.$.timeTooltip.textContent = Math.round(value).toHHMMSS();
                    self.$.timeTooltip.style.left = track.x + "px";
                    self.$.timeTooltip.style.top = (track.y - 25) + "px";
                }

                var drag = function(i) {
                    var tooltip = self.$.timeTooltip;
                    return function(e) {
                        switch (e.detail.state) {
                            case 'start':
                                self.$.grids.classList.add('dragging');
                                break;
                            case 'track':
                                resizeElements(e.detail, i);
                                break;
                            case 'end':
                                self.$.grids.classList.remove('dragging');
                                updateTime(e.detail, i + 1);
                                self.$.timeTooltip.textContent = "";
                                break;
                        }
                    };
                };
                var click = function(i) {
                    return function(e) {
                        self.markAsSelected(i);
                        self.fireSelectionChanged(i);
                    };
                };

                //Remove previous timeline
                while (this.$$(".grid-elem") !== null) {
                    Polymer.dom(this.$.grids).removeChild(this.$$(".grid-elem"));
                }
                //Create new timeline
                for (var i = 0; i < secToSlides.length - 1; i++) {
                    createGridCell(i, (secToSlides[i + 1].time - secToSlides[i].time), createDraggable(i));
                }
                createGridCell(secToSlides.length - 1, (this.duration - secToSlides[secToSlides.length - 1].time));
            }
        });
    </script>
</dom-module>